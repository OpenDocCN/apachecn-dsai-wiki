<!--yml
category: 深度学习
date: 2022-07-01 00:00:00
-->

# Dynamic Routing Between Capsules 译文

<https://www.jianshu.com/p/8d4eefae0444>

胶囊间的动态路由
========

**摘要：**胶囊是一组神经元，其激活向量表示特定类型实体(比如目标或目标部分)的实例化参数。我们用激活向量的长度来表示实体存在的概率，而其方向表示实例化参数。同一层的活性胶囊，通过变换矩阵，对更高层的胶囊的实例化参数进行预测。当多个预测相一致时，较高层的胶囊被激活。我们展示出一个具有判别性的训练，多层胶囊系统在MNIST上实现了最先进的性能，在识别高度重叠的数字时，其效果明显要好于卷积神经网络。为了达到这样的结果，我们使用了迭代路由协议机制：**低层胶囊倾向于将其输出发送到更高层胶囊，更高层胶囊（激活向量具有大的标量积）的预测来自低层胶囊**。

**1 引言**

人类视觉通过使用精心确定的固定点序列来忽略不相关的细节，以确保只有极小部分的光学阵列在最高分辨率下进行处理。针对我们对场景有多少知识来自于固定的顺序以及我们从单一固定中收集多少东西的理解，自省是不太好的指导，但是在本文中，我们将假设单一固定给我们带来的不仅仅是单个确定的对象及其属性。我们假设我们的多层视觉系统在每个固定上创建了一个类似于树状的分析结构，并且我们忽略了这些单一固定的解析树是如何在多个固定上进行协调的问题。

解析树通常是在动态分配内存中构建的。然而，在Hinton等人之后我们假设，对于单一的固定，解析树是由一个固定的多层神经网络雕刻成的，就像雕刻在岩石上的雕塑一样。每层将分成许多小组称为“胶囊”的神经元（Hinton等人），解析树的每个节点对应一个激活胶囊。使用迭代路由过程，每个激活胶囊将在其上层胶囊中选择一个作为父节点。对于较高级别的视觉系统，这个迭代过程将解决部件分配给整体的问题。

激活胶囊内的神经元活动表示图像中存在的特定实体的各种属性。这些属性可以包括许多不同类型的实例化参数，如姿势（位置，大小，方向）、形变、速度、反射率、色调、纹理等等。一个非常特殊的属性是图像中实例化实体的存在。表示实体存在的一个显而易见的方法是用一个独立的逻辑单元，其输出是实体存在的概率。在本文中，我们探索一种有趣的替代方法，即用实例化参数向量的总长度来表示实体的存在，并强制向量的方向来表示实体的属性。我们通过应用非线性使向量的方向不变但是规模缩小，从而保证了胶囊向量的输出长度不超过1。

胶囊的输出是向量的事实使得它可以使用一个强大的动态路由机制以确保胶囊的输出发送至上层合适的父节点。最初，输出被发送到所有可能的父节点，但是被耦合系数缩减总数为1。对于每个可能的父类，胶囊通过将对自身输出乘以一个权重矩阵来计算“预测向量”。如果这个预测向量是一个可能父类输出的一个很大的标量积，那么就有一个自上而下的反馈，增加该父类的耦合系数，并减少其他父节点的耦合系数。这增加了胶囊对于该父节点的贡献，从而进一步增加了使用父节点输出的胶囊预测的标量积。这种类型的“路由协议”要比最大池化（max-pooling）实现的最原始的路由方式更加有效，它允许一层中的神经元忽略除过下面一层的局部池化中最活跃的特征检测器之外所有的。我们证明了我们的动态路由机制是一个可用于解释高度重叠的目标分割的有效方法。

卷积神经网络（CNNs）使用学习特征检测器的变换副本。这使得它们能够将图像中的某个位置获取的良好权重值知识变换到其他位置。这已被证实在图像解释中是非常有帮助的。尽管我们正在用向量-输出胶囊取代CNNs的标量-输出特征检测器，以及用路由协议取代最大池化，但是我们仍然希望在整个空间中复制学到的知识。为了实现该目标，我们让除了胶囊最后一层外的其它层做卷积。与CNNs一样，我们使用更高层的胶囊覆盖图像的更大区域。然而，不同于最大池化，我们不会丢弃远离该区域内实体的精确位置信息。对于低层胶囊，位置信息是激活胶囊的“位置-编码”。随着层次结构的升级，有越来越多的位置信息成为胶囊输出向量实际值分量中的“速度-编码”。从位置-编码到速度-编码的转变，再加上更高层的胶囊代表具有更多自由度更复杂的实体的事实，表明随着层次的提升，胶囊的维度应该会增加。

**2 如何计算胶囊的向量输入和输出**

有很多种可能的方法来实现胶囊的一般概念，本文的目的不是探索这整个空间，而是简单地说明一个相当简单的实现是有效的，并且动态路径规划是有帮助的。

我们用胶囊的输出向量的长度表示胶囊所代表的实体在当前的输入中存在的概率。因此，我们使用一个非线性的“挤压（squashing）”函数以确保短向量被压缩至接近0，长向量被压缩至略低于1。我们让其进行判别性学习以充分利用该非线性。

![](https://img.hacpai.com/e/0447c7437c1f41a5a570351b793c245c.png)

其中v_ j是胶囊 j 的向量输出，s_ j是其总输入。

除了胶囊体第一层外的其他层，胶囊的总输入s_ j是来自于下一层的胶囊所有“预测向量”u_ j|i 的一个加权和，其通过权重矩阵W\_ij 乘以下一层胶囊的输出u\_i 产生。

![](https://img.hacpai.com/e/244a414eb9154b46b6e063fea8594a68.png)

其中c\_ij是由迭代动态路由过程决定的耦合系数。胶囊 i 和高一层的所有胶囊间的耦合系数总和为1，并由“路由softmax”决定，该“路由softmax”的初始逻辑b\_ij 是对数先验概率，即胶囊 i 应该与胶囊 j 耦合。

![](https://img.hacpai.com/e/be8b46d018244b21bed0250cdfbebff8.png)

同一时间的对数先验可以作为所有其他权重来进行判别性的学习。它们取决于两个胶囊的位置和类型，而不是取决于当前的输入图像。然后，初始耦合系数通过测量更高一层中每个胶囊 j 的当前输出v_ j 和胶囊 i 的预测u_ j|i 间的一致性迭代细化。

一致性仅仅是标量积a\_ij=v\_ j.u_ j|i 。这种一致性被认为是一个对数似然比，并在对连接胶囊 i 和更高层胶囊的所有耦合系数计算新值之前，这种一致性被添加到初始逻辑b_ij 。

在卷积胶囊层中，每个胶囊对高一层的每种类型胶囊的输出一个向量的局部网格，并对于网格的每一部分和胶囊的每种类型使用不同的变换矩阵。

![](https://img.hacpai.com/e/68c8ab0346884864b77d283df502b6af.png)

**3 数字存在的边际损失**

我们使用实例化向量的长度来表示胶囊实体存在的概率。当且仅当图像中有数字时，我们想要得到数字类 _k_  的顶层胶囊来获取一个长的实例化向量。为了允许多个数字，我们对每个数字胶囊 _k_ 使用一个单独的边缘损失L_k。

![]()

其中，T_k=1，如果存在一个类 _k_ 的数字，并且m+= 0.9并且m-= 0.1。缺失数字类别的损失的^下降权重会阻止最初学习缩小所有数字胶囊的激活向量的长度。我们用 ^= 0.5。 总损失仅是所有数字胶囊损失的总和。

**4 CapsNet 架构**

        一个简单的CapsNet架构如图1所示。架构可以简单的表示为仅有两个卷积层和一个全连接层组成。Conv1有256个9×9个卷积核，步长为1和ReLU激活。该层将像素的强度转换为之后会用于作为基本胶囊输入的局部特征探测器的激活。

![]()

图1：一个简单的三层CapsNet。这个模型给了深度卷积网络可比较的结果（如Chang and Chen \[2015\]），DigitCaps层中的每个胶囊的激活向量的长度表示每个类的实例呈现，并且用于计算分类损失。W_ ij 是PrimaryCapsule中每个u\_i ，i属于（1，32\*6\*6）和v\_j，j属于（1，10）间的一个权重矩阵。

基本胶囊是多维实体的最低层，并且来自于一个相反的图形视角，激活初始胶囊体对应于反向表现过程。这是一个非常不同的计算方式，而非将实例化的部件组合在一起以形成熟悉的整体，这是胶囊被设计用来擅长做的事情。

第二层（PrimaryCapsules）是一个具有8维胶囊的32通道卷积的胶囊层，（即每个基本胶囊包含8卷积单元，用一个9×9的核和一个长度为2的步长）。每个初始胶囊的输出看作是所有256×81Conv1单元的输出，这些单元可以容纳与胶囊的中心位置重叠的区域。总的PrimaryCapsules有\[32×6×6\]胶囊输出（每个输出都是8维向量），每个胶囊都在\[6×6\]的网格中互相共享权重。PrimaryCapsules作为卷积层用公式1表示，作为其的非线性块。最终层（DigitCaps）有每个数字类是一个16维胶囊，这些胶囊的每一个都是从低一层的所有胶囊中接收输入。

我们仅仅有两个连续的胶囊层之间的路由（即PrimaryCapsules和DigitCaps）。由于Conv1的输出是1维的，在它的空间里没有任何方向可以达成一致。因此，不存在路由是用于Conv1和PrimaryCapsules之间。所有的路由模型（b\_ij）初始化为到0。因此，最初的一个胶囊输出（u\_i）以相等的概率（c\_ij）被发送到所有有父胶囊体（v\_0...v_9）。我们是在TensorFlow（Abadiet al. \[2016\]）进行实验，并且我们使用有着TensorFlow默认参数(包括指数衰减的学习率，最小化方程4中的边缘损失的总和)的Adam优化器（Kingma and Ba \[2014\]）。

**4.1 一种正则化方法——重建**

我们使用额外的重建损失来鼓励数字胶囊去编码输入数字的实例化参数。在训练过程中，我们将除了正确数字胶囊的激活向量外的所有激活向量都屏蔽掉。然后，我们使用这个激活向量重建输入图像。数字胶囊的输出被送入一个由3个模拟像素强度的全连接层组成的解码器，如图2所示。我们最小化逻辑单元和像素强度输出间的平方差异的总和。我们用0.0005缩小重建损失，以至于它在训练中不是边缘损失的主要部分。如图3所示，来自CapsNet的16维输出重建是稳定的，但是只保留了重要细节。

![]()

图2：重建一个来自DigitCaps层表示的数字的解码结构。图像间的欧式距离和Sigmoid层的输出在训练中最小化。我们用正确的标签在训练中作为重建目标。



![]()

图3：用一个有3个路由迭代的CapsNet重建样本MNIST测试。（l，p，r）分别表示标签、预测和重建目标。最右边的两列表示两个错误重建的例子，它解释了该模型如何混淆了这个图像中的5和3。其他的列是正确的分类，并显示模型在平滑噪声的同时保留了许多细节。



![]()

表1：CapsNet分类测试精确度。从三组实验中得到MNIST平均值和标准偏差结果。

**5 MNIST上的Capsules**

在28×28的MNIST（LeCun等人\[1998\]）图像（用填充0在每个方向上提升2个像素实现转移）上进行训练。没有其他数据增加/变形使用。数据集有6万张图片用来训练，1万张图片用来测试。

我们用一个没有任何模型平均的单一模型。Wan等人\[2013\]用旋转和缩放在全部和扩充的数据集上实现了0.21%的测试错误率，在没有旋转和缩放时的测试错误率是是0.39%。我们在一个先前的3层网络上取得了更低的错误率（0.25%），并且只通过加深网络来实现。表1列出了在MNIST上对于不同CapsNet设置的测试错误率，并表明了路由和重建正则化的重要性。通过在胶囊向量中强制构成编码来增加重建正则化矩阵，从而提高了路由性能。

基线是一个分别有256，256，128通道的三个卷积层的标准CNN。每个的核为5x5，步长为1。最后一个卷积层后有两个大小为328，192的全连接层。最后一个全连接层用交叉熵损失连接着dropout和一个10类的softmax层。基线也被用Adam优化器在2像素转移MNIST上进行训练。基线的设计是为了在MNIST上取得最好的性能，同时保持计算成本接近CapsNet。在参数的数量上，基线有3540万，而CapsNet有820万，在没有重建子网络时是680万。

**5.1 一个胶囊的每个维度表示什么**

由于我们只传递一个数字的编码而将其他数字归零，一个数字胶囊的维数应该学会用实例化的类的数字的方式跨越变化的空间。这些变化包括行程厚度（stroke thickness）、倾斜（skew）和宽度（width）。它们还包括数字-特性变化，如一个为2的踪迹长度。通过使用解码网络，我们可以看到每个维度表示的是什么。在计算正确的数字胶囊体的激活向量后，我们可以反馈这个激活向量的一个受扰动的版本到解码网络，并且看看扰动是如何影响重建的。这些扰动的例子如图4所示。我们发现，胶囊的一维（超过16）几乎总是表示数字的宽度。虽然有些维度表示全局变量的组合，但是也有其它维度表示数字的一个局部。例如，用不同的维数提升6的长度和循环的大小。

![]()

图4：维数扰动。每一行显示了当在DigitCaps表示中的16维中的一个是在范围\[-0.25，0.25\]内以间隔为0.05的扭曲。

**5.2 仿射变换的鲁棒性**

实验结果表明，对于每个类别，每一个DigitCaps胶囊比一个传统的卷积网络学习到一个更加鲁棒的表示。因为在手写数字中，在倾斜、旋转、字体等等上有自然地变化，训练的CapsNet对于训练数据小的仿射变换是适当鲁棒的。

为了测试CapsNet对于仿射变换的鲁棒性，我们在填充和变换的MNIST训练集上训练了一个CapsNet和一个传统的卷积网络（有MaxPooling和DropOut），其中每一个例子都是一个随机放置在40×40像素的黑色背景上的MNIST数字。然后，在affNIST数据集上测试这个网络，其中每个样本是一个有着一个随机小仿射变换MNIST数字。除了在标准MNIST中可以看到的平移和一些自然变换，我们的模型从来没有用仿射变换训练过。一个提早停止的训练不足的CapsNet，在扩充的MNIST测试集实现了99.23%的精确度，在affnist测试集上实现了79%的精确度。有着相似的参数数量的传统卷积模型，在扩充的MNIST测试集实现了相似的精确度（99.22%），但是在affnist测试集上仅实现了66%的精确度。

**6 高度分割重叠数字**

动态路由可以被看作是一种并行的注意力机制，它允许在同一层的每个胶囊去关注低一层上的一些激活胶囊并忽略其他的胶囊。这应该允许模型去识别图像中多目标，即使这些目标重叠在一起（Hinton等人\[2000\]），还有其他人在类似的领域内测试了他们的网络（Goodfellow等人\[2013\]、Ba等人\[2014\]、Greff等人\[2016\]）。路由协议应该让它尽可能的用一个关于对象形状的先验帮助分割，且它应该避免在像素领域做出更高层分割决策的需求。

6.1 MutiMNIST数据集

我们通过用相同数据集（训练或测试）但不同的类中的数字，将一个数字重叠在另一个数字上产生了MutiMNIST训练和测试数据集。每个数字在一个36x36的图像上产生每个方向上移4像素。考虑一个在28×28图像中的数字在一个20×20的盒子上是有边界的，两个数字边界的盒子平均有80%的重叠。对于MNIST数据集中的每一个数字，我们产生了1000个MultiMNIST样本。所以训练集的大小是6000万，测试集大小是1000万。

6.2 MultiMNIST结果

我们的3层CapsNet模型在MultiMNIST训练数据上从头开始训练，比我们的基线卷积模型实现了更高的测试分类精确度。在高度重叠的数字对上，我们和Ba等人实现了同为5.0%的分类错误率，而Ba等人\[2014\]连续的注意模型实现了一个更加简单的任务，即不重叠的任务（我们的情况是两个数字的盒子的80%的重叠，而Ba等人\[2014\]等人<4%）。在测试图像（由测试集中的一对图像所组成）上，我们将两个最活跃的数字胶囊作为胶囊网络产生的分类。在重建过程中，我们一次选择一个数字，使用选定的数字胶囊的激活向量来重建选定的数字图像（由于我们用它来产生了一个合成图像，所以我们知道这个图像）。我们MNIST模型的唯一不同是我们将学习速率的衰减阶段增大了10倍，因为我们的训练集更大。

重建过程如图5所示，CapsNet能够将图像分割为两个原始的数字。由于这个分割不是像素级的，当计算所有像素时，我们观察到模型能够正确的处理重叠部分（一个像素出现在两个数字上）。每个数字的位置和字体都在DigitCaps中进行编码。解码器已经学会根据编码重新构造一个数字。事实上，它能够不考虑重叠重建数字，这表明每个数字胶囊可以从来自PrimaryCapsules层的（votes）中获得字体和位置。

![]()

图5：在MultiMNIST测试数据集上3个路由迭代的CapsNet样本重构。两个重构的数字分别覆盖上绿色和红色，红色为更低一层的图像。上面的一行图像是输入图像。L:(l\_1,l\_2)表示图像中两个数字的标签，R:(r\_1,r\_2)表示重建后的两个数字。最右边的两列显示来自标签和来自预测（P）的错误分类重建的两个样本。在（2,8）这个例子中，模型将8和7混淆，在（4,9）中，9和0混淆。其它列都是正确的分类，并显示了在极其困难的场景中（1-4列），分配一个像素给两个数字时模型描述了所有像素。注意，在数据集产生中，像素值被裁减为1。两列用（*）标记的表示的是既不来自于标签也不来自于预测的数字的重建。这些列表明，模型不仅仅是找到对于图像中的所有数字最适合的，包括那些不存在的数字。因此，在（5,0）的情况下，它不能重建一个7，因为它知道这里有一个5和0最合适，可以解释所有像素。在（8,1）的情况下，8的循环不能触发0，因为它已经用8解释。因此，如果它们中的一个没有任何其他支持，它将不会将一个像素分配给两个数字。

表1强调在该任务上路由胶囊的重要性。作为CapsNet分类精确度的基线，我们训练一个有两个卷积层的卷积网络，其上有两个全连接层。第一层有大小为9×9、步长为1的512个卷积核。第二层有大小为5×5、步长为1的256个卷积核。每一个卷积层后，模型有一个尺寸为2×2和步长为2的池化层。第三层是一个1024维的全连接层。所有的这三层都有非线性的ReLU。10个单元组成的最后一层是全连接的。我们使用TensorFlow默认Adam优化器（Kingma和Ba\[2014\]）在最后一层的输出上训练一个sigmoid交叉熵损失。该模型有2456万个参数，是CapsNet的1136万参数的两倍。我们用一个较小的CNN（大小为5×5和步长为1的32和64卷积核和一个512维全卷积层）来开始，递增的增加网络的宽度，直到我们在一个MultiMNIST数据的子数据集1万张图像上达到最好的测试精确度。我们也在1万的验证集上搜索正确的衰减步幅。

我们同时解码两个最活跃的DigitCaps胶囊，并得到两个图像。然后，通过对每个数字用非零强度分配任意像素，我们得到每个数字的分割结果。

**7 其他数据集**

我们在CIFAR10上测试我们的胶囊模型，并在全体7个模型的上实现10.6%错误率，每个模型在24×24的图像块上用3个路由迭代进行训练。每一个模型有相同的结构，作为我们在MNIST上使用的简单模型，除了有三个彩色通道，我们使用初始胶囊的64种不同类型。我们也发现它对路由softmax帮助引入一个“以上都不是”的类别，因为我们没有期望十层胶囊的最后一层去解释图像中的一切事物。10.6%的测试错误率与当他们第一次被应用于CIFAR10（Zeiler和Fergus\[2013\]）时是用什么标准卷积网络实现的有关。

与生成模型共享的胶囊的一个缺点是它喜欢对图像中的所有内容进行说明，因此它可以更好地模拟杂波，而不是在动态路由中使用额外的“孤立”类别。在CIFAR-10中，背景的差异太大，以至于不能对于一个可帮助解释较差性能的在合理的大小的网络中建模。

我们也在smallNOPB（LeCun等人\[2004\]）上测试了与我们对MNIST使用的完全相同的架构，并实现了2.7%的测试错误率，这与最优（Ciresan等人\[2011\]）的结果是相当的。smallNORB数据集由96x96立体声灰度图像组成。我们调整图片至48x48，在训练过程中随机裁剪成32x32。测试期间，我们通过了中心32x32的补丁。

我们也在SVHN（Netzer等人\[2011\]）的仅有73257张图像的小训练集上训练了一个更小的网络。我们减少第一层卷积层的通道数至64，减少初始胶囊层至16，结束层有着8维最终胶囊层的6维-胶囊，在测试集实现了4.3%的错误率。

**8 讨论和先前的工作**

三十年来，在语音识别中最先进的方法是使用将高斯混合作为输出分布的隐马尔可夫模型。这些模型很容易在小型计算机上学习，但它们具有表示的限制，这最终是致命的：他们使用其中的一种表示与使用分布式表示法的递归神经网络相比，是指数效率低下的。要使一个HMM能够记住它所生成的字符串的信息量增加一倍，我们需要将隐层节点的数量平方。对于递归网络，我们只需要将隐层神经元的数量增加一倍。

既然卷积神经网络已经成为了目标识别的主要方法，询问是存在指数效率低导致他们终止的问题是有意义的。一个好的概括新观点的卷积网络的替代者是困难的。建立处理转化的能力，但是对于仿射变换的其它维度，我们得在一个随维数增长而指数增长的网格内复制的特征检测器间选择，或者用一个相似的指数方法增加标记训练集的大小。胶囊（Hinton等人\[2011\]）通过将像素强度转换为识别片段的实例化参数，然后将变换矩阵用于片段来预测更大片段的实例化参数，从而避免指数低效。学习编码一个部分和一个整体间的内在空间关系的变换矩阵构成了自动泛化到新观点的观点不变知识。Hinton等人\[2011\]提出将自动编码器转换为产生PrimaryCapsule层的实例化参数，他们的系统要求在外部提供变换矩阵。我们提出了一个完整的系统，它也可以回答“用激活的、较底层的胶囊预测姿势的协议可以识别多么更大、更复杂的视觉实体”。

胶囊有一个很强的表示假设：在图像的每一个位置，最多有一个胶囊表示的实体类型的实例。这个假设是被一种称为“拥挤”的感知现象激励得到的，它消除了绑定问题（Hinton\[1981a\]），并允许胶囊使用分布式表示（它的激活向量）对一个给定位置的该类型实体的实例化参数进行编码。这种分布式表示比用激活一个高维网格上一点的编码实例化参数的效率要高得多，并且用正确的分布式表示，之后胶囊可以充分利用矩阵乘法建模空间关系的事实。

胶囊使用随着观点变化而变化的神经激活，而不是从激活中消除观点变化。这使得他们比“归一化”方法，如空间变压器网络（Jaderberg等人\[2015\]）更有优势：他们可以同时处理不同目标和目标部分的多个不同的仿射变换。

      胶囊也非常善于处理分割，这是视觉领域的另一个最困难的问题，因为实例化参数的向量允许他们使用路由协议，正如我们在文中说明的那样。动态路由过程的重要性也得到了视觉皮层不变模式识别的生物学模型的支持。Hinton\[1981b\]提出动态连接和基于用于目标识别所产生的形状描述的参考框架的标准识别。Olshausen等人\[1993\]改进了Hinton\[1981b\]动态连接，并给出一个有生物学意义、位置和尺度不变的目标表示的模型。

对胶囊的研究目前正处于一个和本世纪初用于语音识别的递归神经网络的研究相似的阶段。有基础的代表原因让我们相信他是一个更好的方法，但是在它超越高度发达的技术之前，它可能需要更多的小思考。事实上，一个简单的胶囊系统已经在分割重叠数字上提供了无与伦比的性能，这是一个早期迹象，表明胶囊是一个值得探索的方向。

**A  使用了多少路由迭代？**

为了实验验证路由算法的收敛性，我们在每个路由迭代中绘制出路由逻辑的平均变化。图A.1显示每次路由迭代后平均b_ij的变化。从实验上我们观察到，从训练开始到5次迭代时，路由的变化可以忽略不计。路由第2次的平均变化在经过500个阶段的训练为0.007后稳定，而在路由迭代5的过程中，其模型平均变化仅为1e-5。

图A.1：每一次路由迭代的每次路由模型（b_ij）的平均变化。在对MNIST进行了500个周期的训练后，平均变化趋于稳定，如图所示，随着更多的路由迭代，其对数尺度的变化几乎是线性的。



![](https://img.hacpai.com/e/57debafc596e4af5b4b39772c9c1b710.png)

（a）训练过程中



![](https://upload-images.jianshu.io/upload_images/6851347-51d640de364f541b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

（b）最终差异的对数指数

我们观察到，一般来说，更多的路由迭代增加了网络容量，并倾向于过度适应训练数据集。图A.2展示了在Cifar10上当训练1次迭代的路由和3次迭代的路由胶囊训练损失的比较。由图A.2和图A.1的分析，我们建议对所有实验进行3次迭代。

图A.2：在cifar10数据集上训练胶囊网络的损失。每个训练步骤的批量大小为128。具有3次迭代路由的胶囊网络可以更快地优化损失并最终收敛到更低的数值。



![](https://upload-images.jianshu.io/upload_images/6851347-b334e1be3c80def2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

图A.2：在cifar10数据集上的CapsuleNet的损失。每个训练步骤的批处理大小为128。具有3次路由迭代的CapsuleNet，能更快地优化损失，最终收敛到更低的损失。

