# BAT 机器学习 1000 题 101-200

## 101、深度学习（CNN RNN Attention）解决大规模文本分类问题

https://zhuanlan.zhihu.com/p/25928551

## 102、如何解决RNN梯度爆炸和弥散的问题的？

本题解析来源：http://blog.csdn.net/han\_xiaoyang/article/details/51932536

为了解决梯度爆炸问题，Thomas Mikolov首先提出了一个简单的启发性的解决方案，就是当梯度大于一定阈值的的时候，将它截断为一个较小的数。具体如算法1所述：

算法：当梯度爆炸时截断梯度（伪代码）

![](https://img.hacpai.com/e/208c7dc6a0684da29c61a69bbda1c8d3.webp)

下图可视化了梯度截断的效果。它展示了一个小的rnn（其中W为权值矩阵，b为bias项）的决策面。这个模型是一个一小段时间的rnn单元组成；实心箭头表明每步梯度下降的训练过程。当梯度下降过程中，模型的目标函数取得了较高的误差时，梯度将被送到远离决策面的位置。截断模型产生了一个虚线，它将误差梯度拉回到离原始梯度接近的位置。

![](https://img.hacpai.com/e/2bc17b38c4de4831ba49f57159b87293.webp)?

梯度爆炸，梯度截断可视化?

为了解决梯度弥散的问题，我们介绍了两种方法。第一种方法是将随机初始化W(hh)改为一个有关联的矩阵初始化。第二种方法是使用ReLU（Rectified Linear Units）代替sigmoid函数。ReLU的导数不是0就是1.因此，神经元的梯度将始终为1，而不会当梯度传播了一定时间之后变小。

## 103、如何提高深度学习的性能

http://blog.csdn.net/han\_xiaoyang/article/details/52654879

## 104、RNN、LSTM、GRU区别

@我愛大泡泡，本题解析来源：http://blog.csdn.net/woaidapaopao/article/details/77806273

RNN引入了循环的概念，但是在实际过程中却出现了初始信息随时间消失的问题，即长期依赖（Long-Term Dependencies）问题，所以引入了LSTM。

LSTM：因为LSTM有进有出且当前的cell informaton是通过input gate控制之后叠加的，RNN是叠乘，因此LSTM可以防止梯度消失或者爆炸的变化是关键，下图非常明确适合记忆：

![](https://img.hacpai.com/e/3ac47d9da4994418967337c85aa861c2.webp)

GRU是LSTM的变体，将忘记门和输入们合成了一个单一的更新门。?

![](https://img.hacpai.com/e/39768f8a98c249d6bedc6b8405f70305.webp)

## 105、当机器学习性能遭遇瓶颈时，你会如何优化的？

可以从这4个方面进行尝试：、基于数据、借助算法、用算法调参、借助模型融合。当然能谈多细多深入就看你的经验心得了。这里有一份参考清单：机器学习性能改善备忘单（http://blog.csdn.net/han\_xiaoyang/article/details/53453145）

## 106、做过什么样的机器学习项目？比如如何从零构建一个推荐系统

这里有一个推荐系统的公开课http://www.julyedu.com/video/play/18/148，另，再推荐一个课程：机器学习项目班 \[10次纯项目讲解，100%纯实战\]

## 107、什么样的资料集不适合用深度学习?

@抽象猴，来源：https://www.zhihu.com/question/41233373

a.数据集太小，数据样本不足时，深度学习相对其它机器学习算法，没有明显优势。

b.数据集没有局部相关特性，目前深度学习表现比较好的领域主要是图像／语音／自然语言处理等领域，这些领域的一个共性是局部相关性。图像中像素组成物体，语音信号中音位组合成单词，文本数据中单词组合成句子，这些特征元素的组合一旦被打乱，表示的含义同时也被改变。对于没有这样的局部相关性的数据集，不适于使用深度学习算法进行处理。举个例子：预测一个人的健康状况，相关的参数会有年龄、职业、收入、家庭状况等各种元素，将这些元素打乱，并不会影响相关的结果。

## 108、广义线性模型是怎被应用在深度学习中?

@许韩，来源：https://www.zhihu.com/question/41233373/answer/145404190

A Statistical View of Deep Learning (I): Recursive GLMs

深度学习从统计学角度，可以看做递归的广义线性模型。

广义线性模型相对于经典的线性模型(y=wx+b)，核心在于引入了连接函数g(.)，形式变为：y=g?1(wx+b)。

深度学习时递归的广义线性模型，神经元的激活函数，即为广义线性模型的链接函数。逻辑回归（广义线性模型的一种）的Logistic函数即为神经元激活函数中的Sigmoid函数，很多类似的方法在统计学和神经网络中的名称不一样，容易引起初学者（这里主要指我）的困惑。下图是一个对照表![](https://img.hacpai.com/e/9b4756a09fdc415f8f89febb26b37751.webp)

## 109、准备机器学习面试应该了解哪些理论知识

@穆文，来源：https://www.zhihu.com/question/62482926

![](https://img.hacpai.com/e/e551f2fac179408aac76bca30653010d.webp)

看下来，这些问题的答案基本都在本BAT机器学习面试1000题系列里了。

## 110、**标准化与归一化的区别?**

简单来说，标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，将样本的特征值转换到同一量纲下。归一化是依照特征矩阵的行处理数据，其目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”。规则为l2的归一化公式如下：

特征向量的缺失值处理

1\. 缺失值较多.直接将该特征舍弃掉，否则可能反倒会带入较大的noise，对结果造成不良影响。

2\. 缺失值较少,其余的特征缺失值都在10%以内，我们可以采取很多的方式来处理:

1) 把NaN直接作为一个特征，假设用0表示；

2) 用均值填充；

3) 用随机森林等算法预测填充

## 111、随机森林如何处理缺失值

方法一（na.roughfix）简单粗暴，对于训练集,同一个class下的数据，如果是分类变量缺失，用众数补上，如果是连续型变量缺失，用中位数补。

方法二（rfImpute）这个方法计算量大，至于比方法一好坏？不好判断。先用na.roughfix补上缺失值，然后构建森林并计算proximity matrix，再回头看缺失值，如果是分类变量，则用没有阵进行加权平均的方法补缺失值。然后迭代4-6次，这个补缺失值的思想和KNN有些类似1缺失的观测实例的proximity中的权重进行投票。如果是连续型变量，则用proximity矩2。

## 112、随机森林如何评估特征重要性

衡量变量重要性的方法有两种，Decrease GINI 和 Decrease Accuracy：

1) Decrease GINI： 对于回归问题，直接使用argmax(VarVarLeftVarRight)作为评判标准，即当前节点训练集的方差Var减去左节点的方差VarLeft和右节点的方差VarRight。

2) Decrease Accuracy：对于一棵树Tb(x)，我们用OOB样本可以得到测试误差1；然后随机改变OOB样本的第j列：保持其他列不变，对第j列进行随机的上下置换，得到误差2。至此，我们可以用误差1-误差2来刻画变量j的重要性。基本思想就是，如果一个变量j足够重要，那么改变它会极大的增加测试误差；反之，如果改变它测试误差没有增大，则说明该变量不是那么的重要。

## 113、优化Kmeans

使用kd树或者ball tree

将所有的观测实例构建成一颗kd树，之前每个聚类中心都是需要和每个观测点做依次距离计算，现在这些聚类中心根据kd树只需要计算附近的一个局部区域即可。

## 114、KMeans初始类簇中心点的选取

k-means++算法选择初始seeds的基本思想就是：初始的聚类中心之间的相互距离要尽可能的远。

1\. 从输入的数据点集合中随机选择一个点作为第一个聚类中心

2\. 对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x)

3\. 选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大

4\. 重复2和3直到k个聚类中心被选出来

5\. 利用这k个初始的聚类中心来运行标准的k-means算法

## 115、解释对偶的概念

一个优化问题可以从两个角度进行考察，一个是primal 问题，一个是dual 问题，就是对偶问题，一般情况下对偶问题给出主问题最优值的下界，在强对偶性成立的情况下由对偶问题可以得到主问题的最优下界，对偶问题是凸优化问题，可以进行较好的求解，SVM中就是将primal问题转换为dual问题进行求解，从而进一步引入核函数的思想。

## 116、如何进行特征选择？

特征选择是一个重要的数据预处理过程，主要有两个原因：一是减少特征数量、降维，使模型泛化能力更强，减少过拟合;二是增强对特征和特征值之间的理解

常见的特征选择方式：

1\. 去除方差较小的特征

2\. 正则化。1正则化能够生成稀疏的模型。L2正则化的表现更加稳定，由于有用的特征往往对应系数非零。

3\. 随机森林，对于分类问题，通常采用基尼不纯度或者信息增益，对于回归问题，通常采用的是方差或者最小二乘拟合。一般不需要feature engineering、调参等繁琐的步骤。它的两个主要问题，1是重要的特征有可能得分很低（关联特征问题），2是这种方法对特征变量类别多的特征越有利（偏向问题）。

4\. 稳定性选择。是一种基于二次抽样和选择算法相结合较新的方法，选择算法可以是回归、SVM或其他类似的方法。它的主要思想是在不同的数据子集和特征子集上运行特征选择算法，不断的重复，最终汇总特征选择结果，比如可以统计某个特征被认为是重要特征的频率（被选为重要特征的次数除以它所在的子集被测试的次数）。理想情况下，重要特征的得分会接近100%。稍微弱一点的特征得分会是非0的数，而最无用的特征得分将会接近于0。

## 117、数据预处理

1. 缺失值，填充缺失值fillna：

i. 离散：None,

ii. 连续：均值。

iii. 缺失值太多，则直接去除该列

2\. 连续值：离散化。有的模型（如决策树）需要离散值

3\. 对定量特征二值化。核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0。如图像操作

4\. 皮尔逊相关系数，去除高度相关的列

## 118、你知道有哪些数据处理和特征工程的处理？

![](https://img.hacpai.com/e/c8ae0e1c4bbf4c68ab3a0369d9ad5dea.webp)

更多请查看此课程《机器学习工程师 第八期 \[六大阶段、层层深入\]》第7次课 特征工程（https://www.julyedu.com/course/getDetail/65）

## 119、简单说说特征工程![](https://img.hacpai.com/e/a7b0a405b1c94389b0a7765a65cfd1e8.webp)

上图来源：http://www.julyedu.com/video/play/18

## 120、请对比下Sigmoid、Tanh、ReLu这三个激活函数

![](https://img.hacpai.com/e/e61a2b5fe2c04834a444f529da1f751e.webp)

logistic函数，应用在Logistic回归中。<span style="color: rgb(51, 51, 51); font-family:;" new="" times="" 14px;"="">logistic回归的目的是从特征学习出一个0/1分类模型，而这个模型是将特性的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷。因此，使用logistic函数将自变量映射到(0,1)上，映射后的值被认为是属于y=1的概率。

假设函数![](https://img.hacpai.com/e/33fb5b7316e04344ae7bd79c56aa1654.webp)?其中x是n维特征向量，函数g就是logistic函数。

而![](https://img.hacpai.com/e/7b54e9716a8d45dda5c6c5bb455ecb73.webp)的图像是

![](https://img.hacpai.com/e/611b0ba2bd814b5ca82e75ce16a87cd1.webp)

可以看到，将无穷映射到了(0,1)。

而假设函数就是特征属于y=1的概率。

![](https://img.hacpai.com/e/f1fdb9859af14a288a63999a98bf1017.webp)

从而，当我们要判别一个新来的特征属于哪个类时，只需求![](https://img.hacpai.com/e/b03450f5a16a4fd2b522d419fd1854ac.webp)即可，若![](https://img.hacpai.com/e/a425c0f77586473589aba017ea12509e.webp)大于0.5就是y=1的类，反之属于y=0类。

![](https://img.hacpai.com/e/cb58b5071733433dbb574e6581eb48d2.webp)![](https://img.hacpai.com/e/5773902b0ec84596bc4234bc28c3d338.webp)

更多详见：https://mp.weixin.qq.com/s/7DgiXCNBS5vb07WIKTFYRQ

## 121、Sigmoid、Tanh、ReLu这三个激活函数有什么缺点或不足，有没改进的激活函数

@我愛大泡泡，来源：http://blog.csdn.net/woaidapaopao/article/details/77806273![](https://img.hacpai.com/e/1816f05a88234ed88cec1c784e1b8a09.webp)

## 122、怎么理解决策树、xgboost能处理缺失值？而有的模型(svm)对缺失值比较敏感？

https://www.zhihu.com/question/58230411

## 123、为什么引入非线性激励函数？

@Begin Again，来源：https://www.zhihu.com/question/29021768

如果不用激励函数（其实相当于激励函数是f(x)?=?x），在这种情况下你每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。

正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）。最早的想法是sigmoid函数或者tanh函数，输出有界，很容易充当下一层输入（以及一些人的生物解释）。

## 124、请问人工神经网络中为什么ReLu要好过于tanh和sigmoid function?

@Begin?Again，来源：https://www.zhihu.com/question/29021768

第一，采用sigmoid等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。

第二，对于深层网络，sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），从而无法完成深层网络的训练。

第三，Relu会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生（以及一些人的生物解释balabala）。当然现在也有一些对relu的改进，比如prelu，random?relu等，在不同的数据集上会有一些训练速度上或者准确率上的改进，具体的大家可以找相关的paper看。

多加一句，现在主流的做法，会多做一步batch?normalization，尽可能保证每一层网络的输入具有相同的分布\[1\]。而最新的paper\[2\]，他们在加入bypass?connection之后，发现改变batch?normalization的位置会有更好的效果。大家有兴趣可以看下。

\[1\]?Ioffe?S,?Szegedy?C.?Batch?normalization:?Accelerating?deep?network?training?by?reducing?internal?covariate?shift\[J\].?arXiv?preprint?arXiv:1502.03167,?2015.

\[2\]?He,?Kaiming,?et?al.?"Identity?Mappings?in?Deep?Residual?Networks."?arXiv?preprint?arXiv:1603.05027?(2016).?

## 125、为什么LSTM模型中既存在sigmoid又存在tanh两种激活函数？

为什么不是选择统一一种sigmoid或者tanh，而是混合使用呢？这样的目的是什么？

![](https://img.hacpai.com/e/3a6bf01fbfc54c209269d51a6b67c6d5.webp)

本题解析来源：https://www.zhihu.com/question/46197687

@beanfrog：二者目的不一样：sigmoid 用在了各种gate上，产生0~1之间的值，这个一般只有sigmoid最直接了。tanh 用在了状态和输出上，是对数据的处理，这个用其他激活函数或许也可以。

@hhhh：另可参见A Critical Review of Recurrent Neural Networks for Sequence Learning的section4.1，说了那两个tanh都可以替换成别的。

## 126、衡量分类器的好坏。

@我愛大泡泡，来源：http://blog.csdn.net/woaidapaopao/article/details/77806273

这里首先要知道TP、FN（真的判成假的）、FP（假的判成真）、TN四种（可以画一个表格）。?

几种常用的指标：

精度precision = TP/(TP+FP) = TP/~P （~p为预测为真的数量）

召回率 recall = TP/(TP+FN) = TP/ P

F1值： 2/F1 = 1/recall + 1/precision

ROC曲线：ROC空间是一个以伪阳性率（FPR，false positive rate）为X轴，真阳性率（TPR, true positive rate）为Y轴的二维坐标系所代表的平面。其中真阳率TPR = TP / P = recall， 伪阳率FPR = FP / N

## 127、机器学习和统计里面的auc的物理意义是什么？

详情参见https://www.zhihu.com/question/39840928

## 128、观察增益gain, alpha和gamma越大，增益越小？

@AntZ：xgboost寻找分割点的标准是最大化gain. 考虑传统的枚举每个特征的所有可能分割点的贪心法效率太低，xgboost实现了一种近似的算法。大致的思想是根据百分位法列举几个可能成为分割点的候选者，然后从候选者中计算Gain按最大值找出最佳的分割点。它的计算公式分为四项, 可以由正则化项参数调整(lamda为叶子权重平方和的系数, gama为叶子数量):

![](https://img.hacpai.com/e/4247a7fb7ff144879c13425f49628a95.webp)

第一项是假设分割的左孩子的权重分数, 第二项为右孩子, 第三项为不分割总体分数, 最后一项为引入一个节点的复杂度损失

由公式可知, gama越大gain越小, lamda越大, gain可能小也可能大。

原问题是alpha而不是lambda, 这里paper上没有提到, xgboost实现上有这个参数. 上面是我从paper上理解的答案,下面是搜索到的:

https://zhidao.baidu.com/question/2121727290086699747.html?fr=iks&word=xgboost+lamda&ie=gbk

lambda\[默认1\]权重的L2正则化项。(和Ridge regression类似)。 这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。11、alpha\[默认1\]权重的L1正则化项。(和Lasso regression类似)。 可以应用在很高维度的情况下，使得算法的速度更快。

gamma\[默认0\]在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。 这个参数的值越大，算法越保守。

## 129、什么造成梯度消失问题? 推导一下

@许韩，来源：https://www.zhihu.com/question/41233373/answer/145404190

Yes you should understand backdrop－Andrej Karpathy?

How does the ReLu solve the vanishing gradient problem?

神经网络的训练中，通过改变神经元的权重，使网络的输出值尽可能逼近标签以降低误差值，训练普遍使用BP算法，核心思想是，计算出输出与标签间的损失函数值，然后计算其相对于每个神经元的梯度，进行权值的迭代。

梯度消失会造成权值更新缓慢，模型训练难度增加。造成梯度消失的一个原因是，许多激活函数将输出值挤压在很小的区间内，在激活函数两端较大范围的定义域内梯度为0，造成学习停止。![](https://img.hacpai.com/e/d7017046e88f4228a26d5bbeccda52b3.webp)

## 130、什么是梯度消失和梯度爆炸？

@寒小阳，反向传播中链式法则带来的连乘，如果有数很小趋于0，结果就会特别小（梯度消失）；如果数都比较大，可能结果会很大（梯度爆炸）。

@单车，下段来源：https://zhuanlan.zhihu.com/p/25631496

层数比较多的神经网络模型在训练时也是会出现一些问题的，其中就包括梯度消失问题（gradient vanishing problem）和梯度爆炸问题（gradient exploding problem）。梯度消失问题和梯度爆炸问题一般随着网络层数的增加会变得越来越明显。

例如，对于下图所示的含有3个隐藏层的神经网络，梯度消失问题发生时，接近于输出层的hidden layer 3等的权值更新相对正常，但前面的hidden layer 1的权值更新会变得很慢，导致前面的层权值几乎不变，仍接近于初始化的权值，这就导致hidden layer 1相当于只是一个映射层，对所有的输入做了一个同一映射，这是此深层网络的学习就等价于只有后几层的浅层网络的学习了。

![](https://img.hacpai.com/e/d6e18696a8104b059a5684c389b943e4.webp)

而这种问题为何会产生呢？以下图的反向传播为例（假设每一层只有一个神经元且对于每一层![](https://img.hacpai.com/e/92b3c037c48d4cf9ad2086896a7f8b4e.webp)，其中![](https://img.hacpai.com/e/9783eb9756164e5d9faca62adb99f3f0.webp)为sigmoid函数）![](https://img.hacpai.com/e/1e8564fd017d4204a5f90ad27fe0281e.webp)

可以推导出

![](https://img.hacpai.com/e/0d6502a4661348848d03f97a96abf8a6.webp)

而sigmoid的导数![](https://img.hacpai.com/e/255890510e7646238dfeaf63255b259f.webp)如下图

![](https://img.hacpai.com/e/a926f6e105404ccb9a9413c29ee7acad.webp)

可见，![](https://img.hacpai.com/e/b948a753c69f481f80568a28d338b57c.webp)的最大值为1/4，而我们初始化的网络权值|w|通常都小于1，因此![](https://img.hacpai.com/e/1486309d869644abbd978486435ed9a9.webp)，因此对于上面的链式求导，层数越多，求导结果![](https://img.hacpai.com/e/dd3f51f293fe4f4887f85c31a62d6b9f.webp)越小，因而导致梯度消失的情况出现。

这样，梯度爆炸问题的出现原因就显而易见了，即![](https://img.hacpai.com/e/8fd00cb17b2f480d82f5068871dcbe7f.webp)，也就是w比较大的情况。但对于使用sigmoid激活函数来说，这种情况比较少。因为![](https://img.hacpai.com/e/841e6aa5f6e64a808fa2cf0271e9b544.webp)的大小也与w有关（z=wx+b），除非该层的输入值x在一直一个比较小的范围内。

其实梯度爆炸和梯度消失问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。对于更普遍的梯度消失问题，可以考虑用ReLU激活函数取代sigmoid激活函数。另外，LSTM的结构设计也可以改善RNN中的梯度消失问题。

## 131、如何解决梯度消失和梯度膨胀?

（1）梯度消失：

根据链式法则，如果每一层神经元对上一层的输出的偏导乘上权重结果都小于1的话，那么即使这个结果是0.99，在经过足够多层传播之后，误差对输入层的偏导会趋于0

可以采用ReLU激活函数有效的解决梯度消失的情况

（2）梯度膨胀

根据链式法则，如果每一层神经元对上一层的输出的偏导乘上权重结果都大于1的话，在经过足够多层传播之后，误差对输入层的偏导会趋于无穷大

可以通过激活函数来解决

## 132、推导下反向传播Backpropagation

@我愛大泡泡，来源：http://blog.csdn.net/woaidapaopao/article/details/77806273

反向传播是在求解损失函数L对参数w求导时候用到的方法，目的是通过链式法则对参数进行一层一层的求导。这里重点强调：要将参数进行随机初始化而不是全部置0，否则所有隐层的数值都会与输入相关，这称为对称失效。?

大致过程是:

1.首先前向传导计算出所有节点的激活值和输出值，?

![](https://img.hacpai.com/e/8c979b537cfd48c3b93167a88b70f3e4.webp)

2.计算整体损失函数：?

![](https://img.hacpai.com/e/13084479a1d04bd7a8311f3d631f7576.webp)

3.然后针对第L层的每个节点计算出残差（这里是因为UFLDL中说的是残差，本质就是整体损失函数对每一层激活值Z的导数），所以要对W求导只要再乘上激活函数对W的导数即可?

![](https://img.hacpai.com/e/0c23e7378f164fdabd32b7264a6e20ac.webp)?

![](https://img.hacpai.com/e/9d883470cc72494eacfa31089cfff79d.webp)

## 133、SVD和PCA

PCA的理念是使得数据投影后的方差最大，找到这样一个投影向量，满足方差最大的条件即可。而经过了去除均值的操作之后，就可以用SVD分解来求解这样一个投影向量，选择特征值最大的方向。

## 134、数据不平衡问题

这主要是由于数据分布不平衡造成的。解决方法如下：

*   采样，对小样本加噪声采样，对大样本进行下采样

*   进行特殊的加权，如在Adaboost中或者SVM中

*   采用对不平衡数据集不敏感的算法

*   改变评价标准：用AUC/ROC来进行评价

*   采用Bagging/Boosting/ensemble等方法

*   考虑数据的先验分布

## 135、简述神经网络的发展?

MP模型+sgn—->单层感知机（只能线性）+sgn— Minsky 低谷 —>多层感知机+BP+sigmoid—- (低谷) —>深度学习+pre-training+ReLU/sigmoid

## 136、深度学习常用方法

@SmallisBig，来源：http://blog.csdn.net/u010496169/article/details/73550487

全连接DNN（相邻层相互连接、层内无连接）：?

AutoEncoder(尽可能还原输入)、Sparse Coding（在AE上加入L1规范）、RBM（解决概率问题）—–>特征探测器——>栈式叠加 贪心训练?

RBM—->DBN?

解决全连接DNN的全连接问题—–>CNN?

解决全连接DNN的无法对时间序列上变化进行建模的问题—–>RNN—解决时间轴上的梯度消失问题——->LSTM

## 137、神经网络模型（Neural Network）因受人类大脑的启发而得名。

![](https://img.hacpai.com/e/aaf3a02691274c6d8461b18544ef9f3e.webp)

神经网络由许多神经元（Neuron）组成，每个神经元接受一个输入，对输入进行处理后给出一个输出，如下图所示。请问下列关于神经元的描述中，哪一项是正确的？

![](https://img.hacpai.com/e/9b3f602440cf419a951a55773b3c8147.webp)

A.每个神经元只有一个输入和一个输出

B.每个神经元有多个输入和一个输出

C.每个神经元有一个输入和多个输出

D.每个神经元有多个输入和多个输出

E.上述都正确

答案：（E）

每个神经元可以有一个或多个输入，和一个或多个输出。

## 138、下图是一个神经元的数学表示

![](https://img.hacpai.com/e/7d3cf3dc088b4a2e943e1761607b9167.webp)

这些组成部分分别表示为：

- x1, x2,…, xN：表示神经元的输入。可以是输入层的实际观测值，也可以是某一个隐藏层（Hidden Layer）的中间值

- w1, w2,…,wN：表示每一个输入的权重

- bi：表示偏差单元/偏移量（bias unit）。作为常数项加到激活函数的输入当中，类似截距（Intercept）

- a：作为神经元的激励函数（Activation），可以表示为

![](https://img.hacpai.com/e/529604a98da744ffb1a869e0cf2e0143.webp)

- y：神经元输出

考虑上述标注，线性等式（y = mx + c）可以被认为是属于神经元吗：

A． 是

B． 否

答案：（A）

一个不包含非线性的神经元可以看作是线性回归函数（Linear Regression Function）。

## 139、在一个神经网络中，知道每一个神经元的权重和偏差是最重要的一步。如果知道了神经元准确的权重和偏差，便可以近似任何函数，但怎么获知每个神经的权重和偏移呢？

A 搜索每个可能的权重和偏差组合，直到得到最佳值

B 赋予一个初始值，然后检查跟最佳值的差值，不断迭代调整权重

C 随机赋值，听天由命

D 以上都不正确的

答案：（C）选项C是对梯度下降的描述。

## 140、梯度下降算法的正确步骤是什么？

1.计算预测值和真实值之间的误差

2.重复迭代，直至得到网络权重的最佳值

3.把输入传入网络，得到输出值

4.用随机值初始化权重和偏差

5.对每一个产生误差的神经元，调整相应的（权重）值以减小误差

答案：正确步骤排序是：4, 3, 1, 5, 2

## 141、已知：

- 大脑是有很多个叫做神经元的东西构成，神经网络是对大脑的简单的数学表达。

- 每一个神经元都有输入、处理函数和输出。

- 神经元组合起来形成了网络，可以拟合任何函数。

-?为了得到最佳的神经网络，我们用梯度下降方法不断更新模型

给定上述关于神经网络的描述，什么情况下神经网络模型被称为深度学习模型？

A 加入更多层，使神经网络的深度增加

B 有维度更高的数据

C 当这是一个图形识别的问题时

D 以上都不正确

答案：（A）

更多层意味着网络更深。没有严格的定义多少层的模型才叫深度模型，目前如果有超过2层的隐层，那么也可以及叫做深度模型。

## 142、卷积神经网络可以对一个输入进行多种变换（旋转、平移、缩放），这个表述正确吗？

答案：错误

把数据传入神经网络之前需要做一系列数据预处理（也就是旋转、平移、缩放）工作，神经网络本身不能完成这些变换。

## 143、下面哪项操作能实现跟神经网络中Dropout的类似效果？

A Boosting

B Bagging

C Stacking

D Mapping

答案：B

Dropout可以认为是一种极端的Bagging，每一个模型都在单独的数据上训练，同时，通过和其他模型对应参数的共享，从而实现模型参数的高度正则化。

## 144、下列哪一项在神经网络中引入了非线性？

A?随机梯度下降

B?修正线性单元（ReLU）

C?卷积函数

D?以上都不正确

答案：（B）

修正线性单元是非线性的激活函数。

## 145、在训练神经网络时，损失函数(loss)在最初的几个epochs时没有下降，可能的原因是？（）

![](https://img.hacpai.com/e/659c4cc4d2ff4893843220dc86c2999d.webp)

A 学习率(learning?rate)太低

B 正则参数太高

C 陷入局部最小值

D 以上都有可能

答案：（A）

## 146、下列哪项关于模型能力（model capacity）的描述是正确的？（指神经网络模型能拟合复杂函数的能力）

A?隐藏层层数增加，模型能力增加

B?Dropout的比例增加，模型能力增加

C?学习率增加，模型能力增加

D?都不正确

答案：（A）

## 147、如果增加多层感知机（Multilayer Perceptron）的隐藏层层数，分类误差便会减小。这种陈述正确还是错误？

答案：错误

并不总是正确。过拟合可能会导致错误增加。

## 148、构建一个神经网络，将前一层的输出和它自身作为输入。

![](https://img.hacpai.com/e/b0a0b38f94bc41d4a3a588cdf7860494.webp)

下列哪一种架构有反馈连接？

A?循环神经网络

B?卷积神经网络

C?限制玻尔兹曼机

D?都不是

答案：（A）

## 149、下列哪一项在神经网络中引入了非线性？在感知机中（Perceptron）的任务顺序是什么？

1.随机初始化感知机的权重

2.去到数据集的下一批（batch）

3.如果预测值和输出不一致，则调整权重

4.对一个输入样本，计算输出值

答案：1 - 4 - 3 - 2

## 150、假设你需要调整参数来最小化代价函数（cost function），可以使用下列哪项技术？

A． 穷举搜索

B． 随机搜索

C． Bayesian优化

D． 以上任意一种

答案：（D）

## 151、在下面哪种情况下，一阶梯度下降不一定正确工作（可能会卡住）？

![](https://img.hacpai.com/e/85148748ba5c4b019a338a347660be86.webp)

答案：（B）

这是鞍点（Saddle Point）的梯度下降的经典例子。另，本题来源于：https://www.analyticsvidhya.com/blog/2017/01/must-know-questions-deep-learning/。

## 152、下图显示了训练过的3层卷积神经网络准确度，与参数数量(特征核的数量)的关系。

![](https://img.hacpai.com/e/6699ee1b4db149798084baf985fa6001.webp)

从图中趋势可见，如果增加神经网络的宽度，精确度会增加到一个特定阈值后，便开始降低。造成这一现象的可能原因是什么？

A?即使增加卷积核的数量，只有少部分的核会被用作预测

B?当卷积核数量增加时，神经网络的预测能力（Power）会降低

C?当卷积核数量增加时，它们之间的相关性增加(correlate)，导致过拟合

D?以上都不正确

答案：（C）

如C选项指出的那样，可能的原因是核之间的相关性。

## 153、假设我们有一个如下图所示的隐藏层。隐藏层在这个网络中起到了一定的降纬作用。假如现在我们用另一种维度下降的方法，比如说主成分分析法(PCA)来替代这个隐藏层。?

![](https://img.hacpai.com/e/f20e3f1573bc4e518dd43abac71aef5a.webp)

那么，这两者的输出效果是一样的吗？

答案：不同，因为PCA用于相关特征而隐层用于有预测能力的特征

## 154、神经网络能组成函数(y=1/x)吗？

答案：可以，因为激活函数可以是互反函数

## 155、下列哪个神经网络结构会发生权重共享？

A.卷积神经网络

B.循环神经网络

C.全连接神经网络

D.选项A和B

答案：（D）

## 156、批规范化(Batch Normalization)的好处都有啥？

A.在将所有的输入传递到下一层之前对其进行归一化（更改）

B.它将权重的归一化平均值和标准差

C.它是一种非常有效的反向传播(BP)方法

D.这些均不是

答案：（A）

## 157、在一个神经网络中，下面哪种方法可以用来处理过拟合？

A Dropout

B 分批归一化(Batch Normalization)

C 正则化(regularization)

D 都可以

答案：（D）

## 158、如果我们用了一个过大的学习速率会发生什么？

A 神经网络会收敛

B 不好说

C 都不对

D 神经网络不会收敛

答案：（D）

## 159、下图所示的网络用于训练识别字符H和T，如下所示：

**![](https://img.hacpai.com/e/a436c53f51524616a897f4851c49aa48.webp)**

网络的输出是什么？

![](https://img.hacpai.com/e/862cfcee5e9a4c96b85b14fa2f389bba.webp)

D.可能是A或B，取决于神经网络的权重设置

答案：（D）

不知道神经网络的权重和偏差是什么，则无法判定它将会给出什么样的输出。?

## 160、假设我们已经在ImageNet数据集(物体识别)上训练好了一个卷积神经网络。然后给这张卷积神经网络输入一张全白的图片。对于这个输入的输出结果为任何种类的物体的可能性都是一样的，对吗？

A 对的

B 不知道

C 看情况

D 不对

答案：（D）

各个神经元的反应是不一样的

## 161、当在卷积神经网络中加入池化层(pooling layer)时，变换的不变性会被保留，是吗？

A 不知道

B 看情况

C 是

D 否

答案：（C）

使用池化时会导致出现不变性。

## 162、当数据过大以至于无法在RAM中同时处理时，哪种梯度下降方法更加有效？

A 随机梯度下降法(Stochastic Gradient Descent)

B 不知道

C 整批梯度下降法(Full Batch Gradient Descent)

D 都不是

答案：（A）

## 163、下图是一个利用sigmoid函数作为激活函数的含四个隐藏层的神经网络训练的梯度下降图。这个神经网络遇到了梯度消失的问题。下面哪个叙述是正确的？

**![](https://img.hacpai.com/e/af49190b4cc4442791ce4157499b32ed.webp)**

A?第一隐藏层对应D，第二隐藏层对应C，第三隐藏层对应B，第四隐藏层对应A

B?第一隐藏层对应A，第二隐藏层对应C，第三隐藏层对应B，第四隐藏层对应D

C?第一隐藏层对应A，第二隐藏层对应B，第三隐藏层对应C，第四隐藏层对应D

D?第一隐藏层对应B，第二隐藏层对应D，第三隐藏层对应C，第四隐藏层对应A?

答案：（A）

由于反向传播算法进入起始层，学习能力降低，这就是梯度消失。?

## 164、对于一个分类任务，如果开始时神经网络的权重不是随机赋值的，二是都设成0，下面哪个叙述是正确的？

A 其他选项都不对

B 没啥问题，神经网络会正常开始训练

C 神经网络可以训练，但是所有的神经元最后都会变成识别同样的东西

D 神经网络不会开始训练，因为没有梯度改变

答案：（C）

## 165、下图显示，当开始训练时，误差一直很高，这是因为神经网络在往全局最小值前进之前一直被卡在局部最小值里。为了避免这种情况，我们可以采取下面哪种策略？

**![](https://img.hacpai.com/e/e908c83e5000490487e7466a3a8bc049.webp)**

A??改变学习速率，比如一开始的几个训练周期不断更改学习速率

B?一开始将学习速率减小10倍，然后用动量项(momentum)

C?增加参数数目，这样神经网络就不会卡在局部最优处

D?其他都不对?

答案：（A）

选项A可以将陷于局部最小值的神经网络提取出来。

## 166、对于一个图像识别问题(在一张照片里找出一只猫)，下面哪种神经网络可以更好地解决这个问题？

A 循环神经网络

B 感知机

C 多层感知机

D 卷积神经网络

卷积神经网络将更好地适用于图像相关问题，因为考虑到图像附近位置变化的固有性质。

答案：（D）

## 167、假设在训练中我们突然遇到了一个问题，在几次循环之后，误差瞬间降低

**![](https://img.hacpai.com/e/f7d5f8d8d94f4f70a5a5a98cce047790.webp)**

**你认为数据有问题，于是你画出了数据并且发现也许是数据的偏度过大造成了这个问题。?

![](https://img.hacpai.com/e/56869539baed44608f1a6f55a14688e2.webp)**

**你打算怎么做来处理这个问题？**

A?对数据作归一化

B?对数据取对数变化

C?都不对

D?对数据作主成分分析(PCA)和归一化

答案：（D）

首先将相关的数据去掉，然后将其置零。?

## 168、下面那个决策边界是神经网络生成的？?

**![](https://img.hacpai.com/e/04076353d90a4b0cb9622b2847af48df.webp)**

A. A

B. D

C. C

D. B?

E. 以上都有?

答案：（E）

## 169、在下图中，我们可以观察到误差出现了许多小的"涨落"。?这种情况我们应该担心吗？

**![](https://img.hacpai.com/e/717a67a50bef4efb95b581a1404dc380.webp)**

A?需要，这也许意味着神经网络的学习速率存在问题

B?不需要，只要在训练集和交叉验证集上有累积的下降就可以了

C?不知道

D?不好说

答案：（B）

选项B是正确的，为了减少这些“起伏”，可以尝试增加批尺寸(batch?size)。?

## 170、在选择神经网络的深度时，下面那些参数需要考虑？

1 神经网络的类型(如MLP,CNN)2 输入数据3 计算能力(硬件和软件能力决定)4 学习速率5 映射的输出函数

A 1,2,4,5

B 2,3,4,5

C 都需要考虑

D 1,3,4,5

答案：（C）

所有上述因素对于选择神经网络模型的深度都是重要的。

## 171、考虑某个具体问题时，你可能只有少量数据来解决这个问题。不过幸运的是你有一个类似问题已经预先训练好的神经网络。可以用下面哪种方法来利用这个预先训练好的网络？

A 把除了最后一层外所有的层都冻住，重新训练最后一层

B 对新数据重新训练整个模型

C 只对最后几层进行调参(fine tune)

D 对每一层模型进行评估，选择其中的少数来用

答案：（C）

## 172、增加卷积核的大小对于改进卷积神经网络的效果是必要的吗？

答案：不是，增加核函数的大小不一定会提高性能。这个问题在很大程度上取决于数据集。

## 173、请简述神经网络的发展史

@SIY.Z。本题解析来源：https://zhuanlan.zhihu.com/p/29435406

sigmoid会饱和，造成梯度消失。于是有了ReLU。

ReLU负半轴是死区，造成梯度变0。于是有了LeakyReLU，PReLU。

强调梯度和权值分布的稳定性，由此有了ELU，以及较新的SELU。

太深了，梯度传不下去，于是有了highway。

干脆连highway的参数都不要，直接变残差，于是有了ResNet。

强行稳定参数的均值和方差，于是有了BatchNorm。

在梯度流中增加噪声，于是有了 Dropout。

RNN梯度不稳定，于是加几个通路和门控，于是有了LSTM。

LSTM简化一下，有了GRU。

GAN的JS散度有问题，会导致梯度消失或无效，于是有了WGAN。

WGAN对梯度的clip有问题，于是有了WGAN-GP。

## 174、说说spark的性能调优

https://tech.meituan.com/spark-tuning-basic.html

https://tech.meituan.com/spark-tuning-pro.html

175.如何理解LSTM网络？

@Not\_GOD，本题解析来源：http://www.jianshu.com/p/9dc9f41f0b29/

**Recurrent Neural Networks**



人类并不是每时每刻都从一片空白的大脑开始他们的思考。在你阅读这篇文章时候，你都是基于自己已经拥有的对先前所见词的理解来推断当前词的真实含义。我们不会将所有的东西都全部丢弃，然后用空白的大脑进行思考。我们的思想拥有持久性。

传统的神经网络并不能做到这点，看起来也像是一种巨大的弊端。例如，假设你希望对电影中的每个时间点的时间类型进行分类。传统的神经网络应该很难来处理这个问题——使用电影中先前的事件推断后续的事件。

RNN 解决了这个问题。RNN 是包含循环的网络，允许信息的持久化。

![](https://img.hacpai.com/e/9a50e9a6577b4e78b6100d825f91b474.webp)

RNN 包含循环

在上面的示例图中，神经网络的模块，A，正在读取某个输入 x\_i，并输出一个值 h\_i。循环可以使得信息可以从当前步传递到下一步。

这些循环使得 RNN 看起来非常神秘。然而，如果你仔细想想，这样也不比一个正常的神经网络难于理解。RNN 可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个。所以，如果我们将这个循环展开：

![](https://img.hacpai.com/e/1ead3a03c89a41dea8637475e3277f0f.webp)

展开的 RNN

链式的特征揭示了 RNN 本质上是与序列和列表相关的。他们是对于这类数据的最自然的神经网络架构。

并且 RNN 也已经被人们应用了！在过去几年中，应用 RNN 在语音识别，语言建模，翻译，图片描述等问题上已经取得一定成功，并且这个列表还在增长。我建议大家参考 Andrej Karpathy 的博客文章——The Unreasonable Effectiveness of Recurrent Neural Networks?（http://karpathy.github.io/2015/05/21/rnn-effectiveness/）来看看更丰富有趣的 RNN 的成功应用。

而这些成功应用的关键之处就是 LSTM 的使用，这是一种特别的 RNN，比标准的 RNN 在很多的任务上都表现得更好。几乎所有的令人振奋的关于 RNN 的结果都是通过 LSTM 达到的。这篇博文也会就 LSTM 进行展开。

**长期依赖（Long-Term Dependencies）问题**



RNN 的关键点之一就是他们可以用来连接先前的信息到当前的任务上，例如使用过去的视频段来推测对当前段的理解。如果 RNN 可以做到这个，他们就变得非常有用。但是真的可以么？答案是，还有很多依赖因素。

有时候，我们仅仅需要知道先前的信息来执行当前的任务。例如，我们有一个语言模型用来基于先前的词来预测下一个词。如果我们试着预测 “the clouds are in the sky” 最后的词，我们并不需要任何其他的上下文 —— 因此下一个词很显然就应该是 sky。在这样的场景中，相关的信息和预测的词位置之间的间隔是非常小的，RNN 可以学会使用先前的信息。

![](https://img.hacpai.com/e/ccaa81b1dffa4a0391409c049f749801.webp)

不太长的相关信息和位置间隔

但是同样会有一些更加复杂的场景。假设我们试着去预测“I grew up in France... I speak fluent French”最后的词。当前的信息建议下一个词可能是一种语言的名字，但是如果我们需要弄清楚是什么语言，我们是需要先前提到的离当前位置很远的 France 的上下文的。这说明相关信息和当前预测位置之间的间隔就肯定变得相当的大。

不幸的是，在这个间隔不断增大时，RNN 会丧失学习到连接如此远的信息的能力。

![](https://img.hacpai.com/e/30f785c7ef1c4fd4a649efe528310bf9.webp)

相当长的相关信息和位置间隔

在理论上，RNN 绝对可以处理这样的 长期依赖 问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN 肯定不能够成功学习到这些知识。Bengio, et al. (1994)等人对该问题进行了深入的研究，他们发现一些使训练 RNN 变得非常困难的相当根本的原因。

然而，幸运的是，LSTM 并没有这个问题！

**LSTM 网络**



Long Short Term 网络—— 一般就叫做?LSTM ——是一种 RNN 特殊的类型，可以学习长期依赖信息。如@寒小阳所说：LSTM和基线RNN并没有特别大的结构不同，但是它们用了不同的函数来计算隐状态。LSTM的“记忆”我们叫做细胞/cells，你可以直接把它们想做黑盒，这个黑盒的输入为前状态ht?1和当前输入xt。这些“细胞”会决定哪些之前的信息和状态需要保留/记住，而哪些要被抹去。实际的应用中发现，这种方式可以有效地保存很长时间之前的关联信息。



LSTM 由Hochreiter & Schmidhuber (1997)提出，并在近期被Alex Graves进行了改良和推广。在很多问题，LSTM 都取得相当巨大的成功，并得到了广泛的使用。

LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力！

所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层。

![](https://img.hacpai.com/e/95b55342b9a84fec9776ba55e227310d.webp)

标准 RNN 中的重复模块包含单一的层

LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于 单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。

![](https://img.hacpai.com/e/8db3b6faa0a04504a1a7b9ac0166ab70.webp)

LSTM 中的重复模块包含四个交互的层

不必担心这里的细节。我们会一步一步地剖析 LSTM 解析图。现在，我们先来熟悉一下图中使用的各种元素的图标。

![](https://img.hacpai.com/e/f5339f15af654280bfe3472614554d0c.webp)

LSTM 中的图标

在上面的图例中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表 pointwise 的操作，诸如向量的和，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接，分开的线表示内容被复制，然后分发到不同的位置。

**LSTM 的核心思想**



LSTM 的关键就是细胞状态，水平线在图上方贯穿运行。

细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。

![](https://img.hacpai.com/e/c805dedf4425449db3c58a025ae1e781.webp)

LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作。

![](https://img.hacpai.com/e/eef16bcba11f40879d95c26767b78e58.webp)

Sigmoid 层输出 0 到 1 之间的数值，描述每个部分有多少量可以通过。0 代表“不许任何量通过”，1 就指“允许任意量通过”！

LSTM 拥有三个门，来保护和控制细胞状态。

**逐步理解 LSTM**



在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为忘记门层完成。该门会读取?h\_{t-1}?和x\_t，输出一个在 0 到 1 之间的数值给每个在细胞状态?C\_{t-1}?中的数字。1 表示“完全保留”，0 表示“完全舍弃”。

让我们回到语言模型的例子中来基于已经看到的预测下一个词。在这个问题中，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。

![](https://img.hacpai.com/e/2f3ee506ab1c41e3b93aa5587c0fa417.webp)

决定丢弃信息

下一步是确定什么样的新信息被存放在细胞状态中。这里包含两个部分。第一，sigmoid 层称 “输入门层” 决定什么值我们将要更新。然后，一个 tanh 层创建一个新的候选值向量，\\tilde{C}\_t，会被加入到状态中。下一步，我们会讲这两个信息来产生对状态的更新。

在我们语言模型的例子中，我们希望增加新的主语的性别到细胞状态中，来替代旧的需要忘记的主语。

![](https://img.hacpai.com/e/52cd8e92ee044a09bee6dcb8a5acf92f.webp)

确定更新的信息

现在是更新旧细胞状态的时间了，C\_{t-1}?更新为?C\_t。前面的步骤已经决定了将会做什么，我们现在就是实际去完成。

我们把旧状态与?f\_t?相乘，丢弃掉我们确定需要丢弃的信息。接着加上?i\_t \* \\tilde{C}\_t。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。

在语言模型的例子中，这就是我们实际根据前面确定的目标，丢弃旧代词的性别信息并添加新的信息的地方。

![](https://img.hacpai.com/e/c6b568c52da640fab2e2d73e9ccec519.webp)

更新细胞状态

最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。

在语言模型的例子中，因为他就看到了一个?代词，可能需要输出与一个?动词?相关的信息。例如，可能输出是否代词是单数还是负数，这样如果是动词的话，我们也知道动词需要进行的词形变化。

![](https://img.hacpai.com/e/b08956aa1b1940329e2c55ca7326aa6b.webp)

输出信息

**LSTM 的变体**



我们到目前为止都还在介绍正常的 LSTM。但是不是所有的 LSTM 都长成一个样子的。实际上，几乎所有包含 LSTM 的论文都采用了微小的变体。差异非常小，但是也值得拿出来讲一下。

其中一个流形的 LSTM 变体，就是由?Gers & Schmidhuber (2000)?提出的，增加了 “peephole connection”。是说，我们让 门层 也会接受细胞状态的输入。

![](https://img.hacpai.com/e/dd430d320fe0431da4047ab0a3ed74b5.webp)

peephole 连接

上面的图例中，我们增加了 peephole 到每个门上，但是许多论文会加入部分的 peephole 而非所有都加。

另一个变体是通过使用 coupled 忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。我们仅仅会当我们将要输入在当前位置时忘记。我们仅仅输入新的值到那些我们已经忘记旧的信息的那些状态 。

![](https://img.hacpai.com/e/bb1cdddb8d504941a06d4cab41201b79.webp)

coupled 忘记门和输入门

另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由?Cho, et al. (2014)?提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。

![](https://img.hacpai.com/e/1eeaf87a0e334d35af8ec1e6b2d39136.webp)

GRU

这里只是部分流行的 LSTM 变体。当然还有很多其他的，如Yao, et al. (2015)?提出的 Depth Gated RNN。还有用一些完全不同的观点来解决长期依赖的问题，如Koutnik, et al. (2014)?提出的 Clockwork RNN。

要问哪个变体是最好的？其中的差异性真的重要吗？Greff, et al. (2015)?给出了流行变体的比较，结论是他们基本上是一样的。Jozefowicz, et al. (2015)?则在超过 1 万种 RNN 架构上进行了测试，发现一些架构在某些任务上也取得了比 LSTM 更好的结果。

![](https://img.hacpai.com/e/3581ff18ec634021b4e597906b7a1801.webp)

Jozefowicz等人论文截图

**结论**



刚开始，我提到通过 RNN 得到重要的结果。本质上所有这些都可以使用 LSTM 完成。对于大多数任务确实展示了更好的性能！

由于 LSTM 一般是通过一系列的方程表示的，使得 LSTM 有一点令人费解。然而本文中一步一步地解释让这种困惑消除了不少。

LSTM 是我们在 RNN 中获得的重要成功。很自然地，我们也会考虑：哪里会有更加重大的突破呢？在研究人员间普遍的观点是：“Yes! 下一步已经有了——那就是注意力！” 这个想法是让 RNN 的每一步都从更加大的信息集中挑选信息。例如，如果你使用 RNN 来产生一个图片的描述，可能会选择图片的一个部分，根据这部分信息来产生输出的词。实际上，Xu,?et al.(2015)已经这么做了——如果你希望深入探索注意力可能这就是一个有趣的起点！还有一些使用注意力的相当振奋人心的研究成果，看起来有更多的东西亟待探索……

注意力也不是 RNN 研究领域中唯一的发展方向。例如，Kalchbrenner,?et al.?(2015)?提出的 Grid LSTM 看起来也是很有前途。使用生成模型的 RNN，诸如Gregor,?et al.?(2015)Chung,?et al.?(2015)?和?Bayer & Osendorfer (2015)?提出的模型同样很有趣。在过去几年中，RNN 的研究已经相当的燃，而研究成果当然也会更加丰富！

再次说明下，本题解析基本取自Not\_GOD翻译Christopher Olah 博文的《理解LSTM网络》，致谢。

## 176、常见的分类算法有哪些？?

SVM、神经网络、随机森林、逻辑回归、KNN、贝叶斯

## 177、常见的监督学习算法有哪些？?

感知机、svm、人工神经网络、决策树、逻辑回归

## 178、在其他条件不变的前提下，以下哪种做法容易引起机器学习中的过拟合问题（）

A. 增加训练集量

B. 减少神经网络隐藏层节点数

C. 删除稀疏的特征

D. SVM算法中使用高斯核/RBF核代替线性核

正确答案：D

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

一般情况下，越复杂的系统，过拟合的可能性就越高，一般模型相对简单的话泛化能力会更好一点。

B.一般认为，增加隐层数可以降低网络误差（也有文献认为不一定能有效降低），提高精度，但也使网络复杂化，从而增加了网络的训练时间和出现“过拟合”的倾向， svm高斯核函数比线性核函数模型更复杂，容易过拟合

D.径向基(RBF)核函数/高斯核函数的说明,这个核函数可以将原始空间映射到无穷维空间。对于参数 ，如果选的很大，高次特征上的权重实际上衰减得非常快，实际上（数值上近似一下）相当于一个低维的子空间；反过来，如果选得很小，则可以将任意的数据映射为线性可分——当然，这并不一定是好事，因为随之而来的可能是非常严重的过拟合问题。不过，总的来说，通过调整参数 ，高斯核实际上具有相当高的灵活性，也是 使用最广泛的核函数之一。

## 179、下列时间序列模型中,哪一个模型可以较好地拟合波动性的分析和预测？

A.AR模型

B.MA模型

C.ARMA模型

D.GARCH模型

正确答案：D

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

AR模型是一种线性预测，即已知N个数据，可由模型推出第N点前面或后面的数据（设推出P点），所以其本质类似于插值。

MA模型(moving average model)滑动平均模型，其中使用趋势移动平均法建立直线趋势的预测模型。

ARMA模型(auto regressive moving average model)自回归滑动平均模型，模型参量法高分辨率谱分析方法之一。这种方法是研究平稳随机过程有理谱的典型方法。它比AR模型法与MA模型法有较精确的谱估计及较优良的谱分辨率性能，但其参数估算比较繁琐。

GARCH模型称为广义ARCH模型，是ARCH模型的拓展，由Bollerslev(1986)发展起来的。它是ARCH模型的推广。GARCH(p,0)模型，相当于ARCH(p)模型。GARCH模型是一个专门针对金融数据所量体订做的回归模型，除去和普通回归模型相同的之处，GARCH对误差的方差进行了进一步的建模。特别适用于波动性的分析和预测，这样的分析对投资者的决策能起到非常重要的指导性作用，其意义很多时候超过了对数值本身的分析和预测。

## 180、以下哪个属于线性分类器最佳准则?

A.感知准则函数

B.贝叶斯分类

C.支持向量机

D.Fisher准则

正确答案：ACD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

线性分类器有三大类：感知器准则函数、SVM、Fisher准则，而贝叶斯分类器不是线性分类器。

感知准则函数 ：准则函数以使错分类样本到分界面距离之和最小为原则。其优点是通过错分类样本提供的信息对分类器函数进行修正，这种准则是人工神经元网络多层感知器的基础。

支持向量机 ：基本思想是在两类线性可分条件下，所设计的分类器界面使两类之间的间隔为最大，它的基本出发点是使期望泛化风险尽可能小。（使用核函数可解决非线性问题）

Fisher 准则 ：更广泛的称呼是线性判别分析（LDA），将所有样本投影到一条远点出发的直线，使得同类样本距离尽可能小，不同类样本距离尽可能大，具体为最大化“广义瑞利商”。

根据两类样本一般类内密集，类间分离的特点，寻找线性分类器最佳的法线向量方向，使两类样本在该方向上的投影满足类内尽可能密集，类间尽可能分开。这种度量通过类内离散矩阵 Sw 和类间离散矩阵 Sb 实现。

## 181、基于二次准则函数的H-K算法较之于感知器算法的优点是（）?

A.计算量小

B.可以判别问题是否线性可分

C.其解完全适用于非线性可分的情况

D.其解的适应性更好

正确答案：BD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

HK算法思想很朴实,就是在最小均方误差准则下求得权矢量.

他相对于感知器算法的优点在于,他适用于线性可分和非线性可分得情况,对于线性可分的情况,给出最优权矢量,对于非线性可分得情况,能够判别出来,以退出迭代过程.

## 182、以下说法中正确的是（）？

A.SVM对噪声(如来自其他分布的噪声样本)鲁棒

B.在AdaBoost算法中,所有被分错的样本的权重更新比例相同

C.Boosting和Bagging都是组合多个分类器投票的方法,二者都是根据单个分类器的正确率决定其权重

D.给定n个数据点,如果其中一半用于训练,一般用于测试,则训练误差和测试误差之间的差别会随着n的增加而减少

正确答案：BD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

A、SVM对噪声（如来自其他分布的噪声样本）鲁棒

SVM本身对噪声具有一定的鲁棒性，但实验证明，是当噪声率低于一定水平的噪声对SVM没有太大影响，但随着噪声率的不断增加，分类器的识别率会降低。

B、在AdaBoost算法中所有被分错的样本的权重更新比例相同?

AdaBoost算法中不同的训练集是通过调整每个样本对应的权重来实现的。开始时，每个样本对应的权重是相同的，即其中n为样本个数，在此样本分布下训练出一弱分类器。对于分类错误的样本，加大其对应的权重；而对于分类正确的样本，降低其权重，这样分错的样本就被凸显出来，从而得到一个新的样本分布。在新的样本分布下，再次对样本进行训练，得到弱分类器。以此类推，将所有的弱分类器重叠加起来，得到强分类器。

C、Boost和Bagging都是组合多个分类器投票的方法，二者均是根据单个分类器的正确率决定其权重。

**Bagging与Boosting的区别：**

取样方式不同。

Bagging采用均匀取样，而Boosting根据错误率取样。

Bagging的各个预测函数没有权重，而Boosting是有权重的。

Bagging的各个预测函数可以并行生成，而Boosing的各个预测函数只能顺序生成。

## 183、输入图片大小为200×200，依次经过一层卷积（kernel size 5×5，padding 1，stride 2），pooling（kernel size 3×3，padding 0，stride 1），又一层卷积（kernel size 3×3，padding 1，stride 1）之后，输出特征图大小为（）：

A. 95

B. 96

C. 97

D. 98

正确答案：C?

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

首先我们应该知道卷积或者池化后大小的计算公式：?

out\_height=（(input\_height - filter\_height + padding\_top+padding\_bottom)/stride\_height ?）+1

out\_width=（(input\_width - filter\_width + padding\_left+padding\_right)/stride\_width ）+1

其中，padding指的是向外扩展的边缘大小，而stride则是步长，即每次移动的长度。

这样一来就容易多了，首先长宽一般大，所以我们只需要计算一个维度即可，这样，经过第一次卷积后的大小为:?（200-5+2）/2+1，取99；经过第一次池化后的大小为：（99-3）/1+1 为97；经过第二次卷积后的大小为：?（97-3+2）/1+1 为97

## 184、在spss的基础分析模块中，作用是“以行列表的形式揭示数据之间的关系”的是（ ）

A. 数据描述

B. 相关

C. 交叉表

D. 多重相应

正确答案：C

## 185、一监狱人脸识别准入系统用来识别待进入人员的身份，此系统一共包括识别4种不同的人员：狱警，小偷，送餐员，其他。下面哪种学习方法最适合此种应用需求：（）。

A. 二分类问题

B. 多分类问题

C. 层次聚类问题

D. k-中心点聚类问题

E. 回归问题

F. 结构分析问题

正确答案：B

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html?

二分类：每个分类器只能把样本分为两类。监狱里的样本分别为狱警、小偷、送餐员、其他。二分类肯 定行不通。瓦普尼克95年提出来基础的支持向量机就是个二分类的分类器，这个分类器学习过 程就是解一个基于正负二分类推导而来的一个最优规划问题（对偶问题），要解决多分类问题 就要用决策树把二分类的分类器级联，VC维的概念就是说的这事的复杂度。

层次聚类： 创建一个层次等级以分解给定的数据集。监狱里的对象分别是狱警、小偷、送餐员、或者其 他，他们等级应该是平等的，所以不行。此方法分为自上而下（分解）和自下而上（合并）两种操作方式。

K-中心点聚类：挑选实际对象来代表簇，每个簇使用一个代表对象。它是围绕中心点划分的一种规则，所以这里并不合适。

回归分析：处理变量之间具有相关性的一种统计方法，这里的狱警、小偷、送餐员、其他之间并没有什 么直接关系。

结构分析： 结构分析法是在统计分组的基础上，计算各组成部分所占比重，进而分析某一总体现象的内部结构特征、总体的性质、总体内部结构依时间推移而表现出的变化规律性的统计方法。结构分析法的基本表现形式，就是计算结构指标。这里也行不通。

多分类问题： 针对不同的属性训练几个不同的弱分类器，然后将它们集成为一个强分类器。这里狱警、 小偷、送餐员 以及他某某，分别根据他们的特点设定依据，然后进行区分识别。

## 186、关于 logit 回归和 SVM 不正确的是（）

A.Logit回归目标函数是最小化后验概率

B. Logit回归可以用于预测事件发生概率的大小

C. SVM目标是结构风险最小化

D.SVM可以有效避免模型过拟合

正确答案： A

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

A. Logit回归本质上是一种根据样本对权值进行极大似然估计的方法，而后验概率正比于先验概率和似然函数的乘积。logit仅仅是最大化似然函数，并没有最大化后验概率，更谈不上最小化后验概率。而最小化后验概率是朴素贝叶斯算法要做的。A错误

B. Logit回归的输出就是样本属于正类别的几率，可以计算出概率，正确

C. SVM的目标是找到使得训练数据尽可能分开且分类间隔最大的超平面，应该属于结构风险最小化。

D. SVM可以通过正则化系数控制模型的复杂度，避免过拟合。

## 187、有两个样本点，第一个点为正样本,它的特征向量是(0,-1);第二个点为负样本,它的特征向量是(2,3),从这两个样本点组成的训练集构建一个线性SVM分类器的分类面方程是()

A. 2x+y=4

B. x+2y=5

C. x+2y=3

D. 2x-y=0

正确答案：C

解析：这道题简化了，对于两个点来说，最大间隔就是垂直平分线，因此求出垂直平分线即可。

## 188、下面有关分类算法的准确率，召回率，F1 值的描述，错误的是？

A.准确率是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率

B.召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率

C.正确率、召回率和 F 值取值都在0和1之间，数值越接近0，查准率或查全率就越高

D.为了解决准确率和召回率冲突问题，引入了F1分数

正确答案：C

解析：对于二类分类问题常用的评价指标是精准度（precision）与召回率（recall）。通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作：

TP——将正类预测为正类数

FN——将正类预测为负类数

FP——将负类预测为正类数

TN——将负类预测为负类数

由此：

精准率定义为：P = TP / (TP + FP)

召回率定义为：R = TP / (TP + FN)

F1值定义为： F1 = 2 P R / (P + R)

精准率和召回率和F1取值都在0和1之间，精准率和召回率高，F1值也会高，不存在数值越接近0越高的说法，应该是数值越接近1越高。

## 189、以下几种模型方法属于判别式模型(Discriminative Model)的有()

1)混合高斯模型????2)条件随机场模型????3)区分度训练????4)隐马尔科夫模型

A.2,3

B.3,4

C.1,4

D.1,2

正确答案：A

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

常见的判别式模型有：Logistic regression（logistical 回归）

Linear discriminant analysis（线性判别分析）

Supportvector machines（支持向量机）

Boosting（集成学习）

Conditional random fields（条件随机场）

Linear regression（线性回归）

Neural networks（神经网络）

常见的生成式模型有:Gaussian mixture model and othertypes of mixture model（高斯混合及其他类型混合模型）

Hidden Markov model（隐马尔可夫）

NaiveBayes（朴素贝叶斯）

AODE（平均单依赖估计）

Latent Dirichlet allocation（LDA主题模型）

Restricted Boltzmann Machine（限制波兹曼机）

生成式模型是根据概率乘出结果，而判别式模型是给出输入，计算出结果。

## 190、SPSS中，数据整理的功能主要集中在（ ）等菜单中

A.数据

B.直销

C.分析

D.转换

正确答案：AD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

解析：对数据的整理主要在数据和转换功能菜单中。

## 191、深度学习是当前很热门的机器学习算法，在深度学习中，涉及到大量的矩阵相乘，现在需要计算三个稠密矩阵A,B,C的乘积ABC,假设三个矩阵的尺寸分别为m?n，n?p，p?q，且m<n<p<q，以下计算顺序效率最高的是（）?

A.(AB)C

B.AC(B)

C.A(BC)

D.所以效率都相同

正确答案：A

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

首先，根据简单的矩阵知识，因为 A\*B ， A 的列数必须和 B 的行数相等。因此，可以排除 B 选项，?

然后，再看 A 、 C 选项。在 A 选项中，m?n 的矩阵 A 和n?p的矩阵 B 的乘积，得到 m?p的矩阵 A\*B ，而 A?B的每个元素需要 n 次乘法和 n-1 次加法，忽略加法，共需要 m?n?p次乘法运算。同样情况分析 A\*B 之后再乘以 C 时的情况，共需要 m?p?q次乘法运算。因此， A 选项 (AB)C 需要的乘法次数是 m?n?p+m?p?q 。同理分析， C 选项 A (BC) 需要的乘法次数是 n?p?q+m?n?q。?

由于m?n?p<m?n?q，m?p?q<n?p?q，显然 A 运算次数更少，故选 A 。

## 192、Nave Bayes是一种特殊的Bayes分类器,特征变量是X,类别标签是C,它的一个假定是:()?

A.各类别的先验概率P(C)是相等的

B.以0为均值，sqr(2)/2为标准差的正态分布

C.特征变量X的各个维度是类别条件独立随机变量

D.P(X|C)是高斯分布

正确答案：C

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

朴素贝叶斯的条件就是每个变量相互独立。

## 193、关于支持向量机SVM,下列说法错误的是（）?

A.L2正则项，作用是最大化分类间隔，使得分类器拥有更强的泛化能力

B.Hinge 损失函数，作用是最小化经验分类错误

C.分类间隔为1/||w||，||w||代表向量的模

D.当参数C越小时，分类间隔越大，分类错误越多，趋于欠学习

正确答案：C

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

A正确。考虑加入正则化项的原因：想象一个完美的数据集，y>1是正类，y<-1是负类，决策面y=0，加入一个y=-30的正类噪声样本，那么决策面将会变“歪”很多，分类间隔变小，泛化能力减小。加入正则项之后，对噪声样本的容错能力增强，前面提到的例子里面，决策面就会没那么“歪”了，使得分类间隔变大，提高了泛化能力。

B正确。

C错误。间隔应该是2/||w||才对，后半句应该没错，向量的模通常指的就是其二范数。

D正确。考虑软间隔的时候，C对优化问题的影响就在于把a的范围从\[0，+inf\]限制到了\[0,C\]。C越小，那么a就会越小，目标函数拉格朗日函数导数为0可以求出w=求和ai?yi?xi，a变小使得w变小，因此间隔2/||w||变大

## 194、在HMM中,如果已知观察序列和产生观察序列的状态序列,那么可用以下哪种方法直接进行参数估计()?

A.EM算法

B.维特比算法

C.前向后向算法

D.极大似然估计

正确答案：D

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

EM算法： 只有观测序列，无状态序列时来学习模型参数，即Baum-Welch算法

维特比算法： 用动态规划解决HMM的预测问题，不是参数估计

前向后向算法：用来算概率

极大似然估计：即观测序列和相应的状态序列都存在时的监督学习算法，用来估计参数

注意的是在给定观测序列和对应的状态序列估计模型参数，可以利用极大似然发估计。如果给定观测序列，没有对应的状态序列，才用EM，将状态序列看不不可测的隐数据。

## 195、假定某同学使用Naive Bayesian（NB）分类模型时，不小心将训练数据的两个维度搞重复了，那么关于NB的说法中正确的是：?

A.这个被重复的特征在模型中的决定作用会被加强

B.模型效果相比无重复特征的情况下精确度会降低

C.如果所有特征都被重复一遍，得到的模型预测结果相对于不重复的情况下的模型预测结果一样。

D.当两列特征高度相关时，无法用两列特征相同时所得到的结论来分析问题

E.NB可以用来做最小二乘回归

F.以上说法都不正确

正确答案：BD

## 196、L1与L2范数

在Logistic Regression 中,如果同时加入L1和L2范数,会产生什么效果()

A.可以做特征选择,并在一定程度上防止过拟合

B.能解决维度灾难问题

C.能加快计算速度

D.可以获得更准确的结果

正确答案:A

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

Ｌ１范数具有系数解的特性，但是要注意的是，Ｌ１没有选到的特征不代表不重要，原因是两个高相关性的特征可能只保留一个。如果需要确定哪个特征重要，再通过交叉验证。

在代价函数后面加上正则项，Ｌ１即是Ｌｏｓｓｏ回归，Ｌ２是岭回归。L1范数是指向量中各个元素绝对值之和，用于特征选择。L2范数 是指向量各元素的平方和然后求平方根，用于 防止过拟合，提升模型的泛化能力。因此选择A。

对于机器学习中的范数规则化，也就是L0,L1,L2范数的详细解答，请参阅《范数规则化》(http://blog.csdn.net/zouxy09/article/details/24971995/)

## 197、正则化

机器学习中L1正则化和L2正则化的区别是？

A.使用L1可以得到稀疏的权值

B.使用L1可以得到平滑的权值

C.使用L2可以得到稀疏的权值

D.使用L2可以得到平滑的权值

正确答案:AD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

L1正则化偏向于稀疏，它会自动进行特征选择，去掉一些没用的特征，也就是将这些特征对应的权重置为0.

L2主要功能是为了防止过拟合，当要求参数越小时，说明模型越简单，而模型越简单则，越趋向于平滑，从而防止过拟合。

L1正则化/Lasso?

L1正则化将系数w的l1范数作为惩罚项加到损失函数上，由于正则项非零，这就迫使那些弱的特征所对应的系数变成0。因此L1正则化往往会使学到的模型很稀疏（系数w经常为0），这个特性使得L1正则化成为一种很好的特征选择方法。

L2正则化/Ridge regression?

L2正则化将系数向量的L2范数添加到了损失函数中。由于L2惩罚项中系数是二次方的，这使得L2和L1有着诸多差异，最明显的一点就是，L2正则化会让系数的取值变得平均。对于关联特征，这意味着他们能够获得更相近的对应系数。还是以Y=X1+X2为例，假设X1和X2具有很强的关联，如果用L1正则化，不论学到的模型是Y=X1+X2还是Y=2X1，惩罚都是一样的，都是2alpha。但是对于L2来说，第一个模型的惩罚项是2alpha，但第二个模型的是4\*alpha。可以看出，系数之和为常数时，各系数相等时惩罚是最小的，所以才有了L2会让各个系数趋于相同的特点。

可以看出，L2正则化对于特征选择来说一种稳定的模型，不像L1正则化那样，系数会因为细微的数据变化而波动。所以L2正则化和L1正则化提供的价值是不同的，L2正则化对于特征理解来说更加有用：表示能力强的特征对应的系数是非零。

因此，一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。Lasso在特征选择时候非常有用，而Ridge就只是一种规则化而已。

具体的，可以参阅《机器学习之特征选择》与《机器学习范数正则化》。

## 198、势函数法

位势函数法的积累势函数K(x)的作用相当于Bayes判决中的()

A.后验概率

B.先验概率

C.类概率密度

D.类概率密度与先验概率的乘积

正确答案:AD

@刘炫320，本题题目及解析来源：http://blog.csdn.net/column/details/16442.html

事实上，AD说的是一回事。?具体的，势函数详解请看——《势函数法》。

## 199、隐马尔可夫

隐马尔可夫模型三个基本问题以及相应的算法说法正确的是（ ）

A.评估—前向后向算法

B.解码—维特比算法

C.学习—Baum-Welch算法

D.学习—前向后向算法

正确答案:ABC

解析：评估问题，可以使用前向算法、后向算法、前向后向算法。

## 200、特征比数据量还大时，选择什么样的分类器？

线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分。
